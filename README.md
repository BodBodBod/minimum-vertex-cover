# Задача минимального вершинного покрытия графа

## Описание проекта

В репозитории реализованы алгоритмы решения задачи минимального вершинного покрытия графа:

- **Greedy Independent Set Approximation**: Аппроксимация задачи минимального вершинного покрытия с использованием жадного подхода для нахождения независимого множества.
- **Simulated Annealing**: Алгоритм имитации отжига для нахождения минимального вершинного покрытия.

Алгоритмы позволяют находить приближённое решение задачи, которая относится к классу NP-полных.

## Файлы
- **min_vertex_cover.py** — реализация алгоритмов.
- **simple_example.ipynb** — пример использования:
    - Импорт методов
    - Задание графа
    - Применение алгоритмов для нахождения минимального вершинного покрытия

---

## Постановка задачи

**Минимальное вершинное покрытие (Minimum Vertex Cover)** — это наименьшее множество вершин в графе, такое что каждое ребро инцидентно хотя бы одной вершине из этого множества.

> Найти $C \subseteq V$ такое, что $\forall (u, v) \in E$, $u \in C$ или $v \in C$, и $|C|$ минимально.

---

## Входные данные

Входной граф является неориентированным, в виде словаря `dict[str, list[str]]`, ключи словаря являются именами вершин, а значения — списками соседей.

Пример графа:
```python
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B', 'E'],
    'E': ['B', 'D', 'F'],
    'F': ['C', 'E']
}
```
---
## Описание методов
### Greedy Independent Set Approximation (```GIS_approximation```)

Максимальное независимое множество — это набор вершин, между которыми нет рёбер. Его дополнение относительно всех вершин графа является приближением к минимальному вершинному покрытию.

#### Метод и принцип работы
1. Копируем граф для безопасной трансформации.

2. Итерируем:
   - выбираем вершину с наибольшей степенью: ```max_degree_node(graph)```
   - добавляем её в независимое множество: ```independent_set```
   - удаляем её и всех соседей
   - пересчитываем связи оставшихся вершин
     
3. Возвращаем: ```min_vertex_cover = set(graph.keys()) - independent_set```

### Simulated Annealing (```simulated_annealing```)

Метод имитации отжига ищет глобальный минимум функции стоимости (```pricing_function```) путём случайных модификаций решения с контролем температуры, эвристически такой подход к принятию худших решений, чем текущее, позволяет "перепрыгивать" через локальные минимумы.

#### Метод и принцип работы
Основной метод: ```simulated_annealing```
Аргументы:
- Граф: ```graph: Dict[str, List[str]]```
- Начальное приближение: ```initial_solution: Set[str]```
  > При отсутсвии начального приближения, оно будет вычислено как полученное с помощью Greedy Independent Set Approximation решение
- Время выполнения в секундах: ```cutoff```
- Начальная температура: ```T```
- Коэффициент понижения температуры: ```T_coeff```

    
Принцип работы
1. Инициализация начального решения — результат GIS_approximation или любое другое подмножество вершин графа

2. Пока не достигнут ```cutoff```, температура ```T``` уменьшается с коэффициентом ```T_coeff```
     
3. Для каждого ```T```
    - Максимальное число итераций: $(|V| - |sol| - 1)^2$,  
   $V$ -- множество вершин графа, $sol$ -- множество вершин в текущем решении
    - На каждой итерации принимаем решение
      - Лучшее (с точки зрения значения ```pricing_function```) решение с вероятностью 1
      - Худшее решение с вероятностью $exp(-Δ/T)$  

    
```pricing_function``` оценивает решение как кол-во непокрытых ребер графа, на вход принимает:
- Граф: ```graph: Dict[str, List[str]]```
- Текущее решение (которое надо взвесить): ```candidate_solution: Set[str]```  

    
Замыкание ```make_choice_between_solutions```  позволяет сравнить два решения между собой с точки зрения ```pricing_function```, на вход принимает:
- Граф: ```graph: Dict[str, List[str]]```
И возвращает функцию ```choose_solution```, которая для этого графа сравнивает решения
```current_solution: Set[str]``` и ```sol: Set[str], T: float```
после чего принимает решение о принятии решения
